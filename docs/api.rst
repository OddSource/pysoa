.. contents:: Contents
   :depth: 3
   :backlinks: none


Core concepts
-------------

Services in ``pysoa`` are built around a client-server model with a simple service API. The core abstractions of this API are Jobs and Actions. An Action is a unit of work performed by a Server, and a Job is a container of Actions.


Basic request flow
++++++++++++++++++

A Client may make a request to a Server by sending it a ``JobRequest`` containing one or more ``ActionRequest`` objects, and some header information. The Server processes the Job by executing each Action in the Job, in order, using the appropriate Action handler method for each Action. The results returned or exceptions raised by each Action handler are collected into a ``JobResponse``. When the Job execution terminates, either because all of the Actions have been processed or due to an exception, the Server returns the ``JobResponse`` to the Client.


Message data structures
+++++++++++++++++++++++


JobRequest
**********

The ``JobRequest`` object contains a list of ``ActionRequest`` objects along with two headers: ``control`` and ``context``. Both of these headers are provided to the action handler when processing each ``ActionRequest`` In general, the ``control`` header is used for flags that affect the execution of the Job itself, such as how to handle Action errors. The ``context`` header is for everything else, including switches (see `Versioning using switches`_) and metadata.

- ``control``: Stores values that affects the execution of the job itself.

  + ``continue_on_error``: Tells the Server to continue processing the job if any action results in an error (``bool``).

- ``context``: Stores other information about the request.

  + ``switches``: A list of switch values (see below).
  + ``correlation_id``: A unique ID that is generated by the Client and follows the job. Must be passed to any other service calls made while processing the job. Used to facilitate metrics (``str``).

- ``actions``: A list containing ``ActionRequests``.


ActionRequest
*************

- ``action``: The name of the action (``str``).

- ``body``: A dict containing arguments for the action.


JobResponse
***********

- ``actions``: A list of ``ActionResponses``

- ``errors``: A list of ``Errors``


ActionResponse
**************

- ``action``: The name of the action (``str``).

- ``errors``: A list of ``Errors``.

- ``body``: A dict containing the return value of the action.


Error
*****

- ``code``: A numerical error code (``int``).

- ``message``: A human-readable error message (``str``).

- ``field``: An identifier of the form ``'field.subfield'`` for the field in the ``ActionRequest`` that caused the error, if applicable (``str``).



Servers
-------


The ``server`` module contains everything necessary to write a ``pysoa`` service. The ``Action`` class provides the parent class for your service's Actions, which are the main units of business logic, while ``Server`` class provides the framework for running a request-response loop.

The ``Server`` is the heart of any ``pysoa`` service. It provides a standard Job processing workflow and an interface for subclasses to implement Action handlers. It also provides a simple command line interface.

In general, ``Server`` subclasses will need to define two things: the service name and a mapping of Action names to Action handlers. Subclasses may also perform additional setup by overriding the ``setup`` method of the base class. Subclasses should not need to override any other methods on the base class.

The ``Action`` class provides an interface allowing subclasses to easily validate input, execute business logic and validate output. Validation is performed by `conformity <https://github.com/eventbrite/conformity>`_ schema, allowing for simple, declarative input and output checking. It automatically handles validating the dict returned by the ``run`` method and transforming it into an ``ActionResponse`` object.


``Server``
++++++++++

Properties:

- ``service_name``: Name that the service will use to identify itself, and that Clients will use to call it (``str``).
- ``action_class_map``: A mapping of Action names to handlers, which are ``Action`` subclasses (``dict``).
- ``use_django``: If this is ``True``, ``Server.main`` will import settings from Django.

Methods:

- ``setup``: Performs service-specific setup. Takes no arguments.
- ``main``: Class method that allows the Server to be run from the command line.


``Action``
++++++++++

Properties:

- ``request_schema``: A conformity schema defining the structure of the request body.
- ``response_schema``: A conformity schema defining the structure of the response body.

Methods:

- ``validate``: A method that performs custom validation. Takes an ``ActionRequest`` object as input, and raises an ``ActionError`` to signal validation failure; otherwise, returns ``None``.
- ``run``: The main method that performs business logic. Takes an ``ActionRequest`` as input and returns a ``dict`` matching the schema defined in ``response_schema`` or raises an ``ActionError``.


Server configuration
++++++++++++++++++++

The ``Server`` base class takes configuration in the form of a dict with the following format::

    {
        "transport": <transport config>,
        "serializer": <serializer config>,
        "middleware": [<middleware config>, ...],
        "client_routing": <client settings>,
        "logging": <logging config>,
        "harakiri": {
            "timeout": <harakiri timeout>,
            "shutdown_grace": <harakiri shutdown grace>,
        }
    }

Key:

- ``<transport config>``: See `Transport configuration`_. The base ``Server`` defaults to using the `ASGI Transport`_.
- ``<serializer config>``: See `Serializer configuration`_. The base ``Server`` defaults to using the `MessagePack Serializer`_.
- ``<middleware config>``: See `Middleware configuration`_.
- ``<client settings>``: Configuration for a ``Client`` that can be used to make further service calls during Action processing. See `Client configuration`_.
- ``<logging config>``: A dictionary that will be used to configure the ``logging`` module at ``Server`` startup (`logging config schema <https://docs.python.org/3/library/logging.config.html#logging-config-dictschema>`_).
- ``<harakiri timeout>``: Server will shut down if it is inactive for this many seconds.
- ``<harakiri shutdown grace>``: When shutting down after ``<harakiri timeout>``, the server will wait this many seconds for jobs to finish before forcing shutdown.


Django integration
++++++++++++++++++

The ``Server`` class is able to get configuration from Django settings automatically. If the ``use_django`` property on the ``Server`` subclass is ``True``, the ``main`` method will automatically import the Django settings module and look for configuration under the name ``SOA_SERVER_SETTINGS``.


Versioning using switches
+++++++++++++++++++++++++

Switches are like a special argument that every action in a job gets. In terms of code, switches are simply integers passed by the Client in the control header of every ``JobRequest``, and then by the Server into every action in that job.

Switches came from a need to version individual service actions, rather than versioning the whole service at once. To do this, implement a switching function that calls a different action depending on the switches in the ``ActionRequest``. For example::


    MY_ACTION_V2 = 1

    class MyAction(Action):
        ...

    class MyActionV2(Action):
        ...

    def my_action(action_request):
        if MY_ACTION_V2 in action_request.switches:
            return MyActionV2(action_request)
        else:
            return MyAction(action_request)



Clients
-------

Code that needs to call one or more services will do so using a ``Client``. A single ``Client`` can be configured to call any number of services.

The ``client`` submodule provides the ``Client`` class as well as base classes for settings and middleware. Unlike the ``Server``, ``Client`` will generally not be subclassed unless there is a need to add nonstandard behavior on top of the base ``Client``. 


``Client``
++++++++++

Methods:

- ``__init__`` - Args:

  + ``config``: Configuration dict (see `Configuring Servers and Clients`_).
  + ``expansions`` (optional): A mapping of service name to expansion (see `Expansions`_).
  + ``settings_class`` (optional): A ``Settings`` subclass to use for configuration validation. Defaults to the class's ``settings_class`` property.
  + ``context``: A dict of context information that will be included in the ``JobRequest.context`` on every request.

- ``send_request`` - Build and send a ``JobRequest`` and returns an integer request ID. Args:

  + ``service_name``: Name of the service to call (``str``).
  + ``actions``: List of ``ActionRequest`` objects or dicts that fulfill the ``ActionRequest`` schema.
  + ``switches``: List of numerical switch values (see `Versioning using switches`_).
  + ``correlation_id``, ``continue_on_error`` (optional): Values that will be included in ``JobRequest.control``.
  + ``control_extra`` (optional): A dict containing any extra values that will be included in ``JobRequest.control``.
  + ``context`` (optional): Corresponds to the ``context`` dict in ``JobRequest``.

- ``get_all_responses`` - Returns a generator with all outstanding ``JobResponse`` objects for the given service. Should be called after one or more calls to ``Client.send_request``. Args:

  + ``service_name``: Name of the service to get responses for (``str``).

- ``call_actions`` - Build and send a ``JobRequest`` with one or more Actions and return a ``JobResponse``. Takes the same arguments as ``Client.send_request``.

- ``call_action`` - Build and send a ``JobRequest`` with a single Action and return an ``ActionResponse``. Args:

  + ``service_name``: Name of the service to call (``str``).
  + ``action``: The action name (``str``).
  + ``body`` (optional): A dict containing arguments for the action.
  + ``switches``, ``correlation_id``, ``control_extra``, ``context``: as in ``send_request``.


Client configuration
++++++++++++++++++++

The ``Client`` class takes configuration in the form of a dict with the following format::

    {
        <service name>: {
            "transport": <transport config>,
            "serializer": <serializer config>,
            "middleware": [<middleware config>, ...],
        },
        ...
    }

Key:

- ``<service name>``: The ``Client`` needs settings for each service that it will call, keyed by service name.
- ``<transport config>``: See `Transport configuration`_. The base ``Client`` defaults to using the `ASGI Transport`_.
- ``<serializer config>``: See `Serializer configuration`_. The base ``Client`` defaults to using the `MessagePack Serializer`_.
- ``<middleware config>``: See `Middleware configuration`_.


Expansions
++++++++++

Expansions allow ``Client.call_actions`` to automatically "expand" fields in a service response by making further service calls and adding those responses to the original response.

Expansions are based on a type system, which is optional and requires extra effort on the part of services. To support expansions, services must include a ``_type`` field in each object in each ``ActionResponse`` body. The indicated type must map to an expansion type in the ``Client`` expansion configuration.

The ``Client.call_actions`` and ``Client.call_action`` methods take a keyword argument ``expansions``, which is a dictionary mapping types to expansions. For each ``<type>: <expansions>`` pair, the ``Client`` will automatically perform each expansion in ``<expansions>`` for each object of ``<type>`` in the response.


Configuring expansions
**********************

Expansions are configured on the ``Client`` instance by using the ``expansions`` argument on initialization. This argument accepts a dict with the following format::

    {
        "type_routes": {...},
        "type_expansions": {...},
    }

``type_routes`` configuration format::

    {
        <type>: {
            "service": <service name>,
            "action": <action name>,
            "request_field": <request field name>,
            "response_field": <response field name>,
        },
        ...
    }

Key:

- ``<type>``: The type of the expansion.
- ``<service name>``: The name of the service to call.
- ``<action name>``: The name of the action to call.
- ``<request field>``: The name of the field to use in the ``ActionRequest`` body. The value of the field will be the expansion identifier extracted from the object being expanded.
- ``<response field>``: The name of the field returned in the ``ActionResponse`` body that contains the expansion object.

To satisfy an expansion, the expansion processing code needs to know which service action to call and how to call it. Type routes solve this problem by by giving the expansion processing code all the information it needs to properly call a service action to satisfy an expansion.


``type_expansions`` configuration format::

    {
        <type>: {
            <expansion name>: {
                "type": <expansion type>,
                "source_field": <source field name>,
                "dest_field": <destination field name>,
                "raise_action_errors": <bool>,
            },
            ...
        },
        ...
    }

Key:

- ``<type>``: A type for which you are defining expansions.
- ``<expansion name>``: The name of an expansion.
- ``<expansion type>``: The type of the expansion. This is used to look up the appropriate expansion route in the Type Route Configuration.
- ``<source field name>``: The name of the field on an object of type ``<type>`` that contains the value of the expansion identifier.
- ``<destination field name>``: The name of the field on an object of type ``<type>`` that will be filled with the expanded value.

Type expansions detail the expansions that are supported for each type. If a ``Client`` needs to support expansions for a type, that type must have a corresponding entry in the Type Expansions Configuration dictionary.


Expansions example
******************

Consider a ``Client`` with the following expansions config::

    {
        "type_routes": {
            "bar": {
                "service": "bar_example",
                "action": "get_bar",
                "request_field": "id",
                "response_field": "bar",
            },
        },
        "type_expansions": {
            "foo": {
                "bar": {
                    "type": "bar",
                    "source_field": "bar_id",
                    "dest_field": "bar",
                },
            },
        },
    }

We make a call to the ``foo_example`` service using the ``expansions`` argument::

    result = client.call_actions(
        service_name="foo_example",
        actions=[
            {
                "action": "get_foo",
                "body": {"id": 1},
            }
        ],
        expansions={"foo": ["bar"]},
    )

The argument ``expansions={"foo": ["bar"]}`` tells the ``Client`` "for each object of type ``foo`` in the response, perform an expansion of type ``bar``".

The ``foo_example`` service returns the following response to our ``get_foo`` request::

    {
        "action": "get_foo",
        "errors": [],
        "body": {
            "foo": {
                "_type": "foo",
                "id": 1,
                "bar_id": 2,
            },
        },
    }

Note that the ``foo`` object contains the field ``bar_id``, which corresponds to the ``source_field`` in the ``bar`` expansion.

Using this response, the ``Client`` automatically makes a call to the ``bar_example`` service using the ``bar_id`` from the ``foo`` response, like so::

    client.call_action(
        service_name="bar_example",
        body={
            "action": "get_bar",
            "body": {"id": 2},
        },
    )

The ``bar_example`` service returns the following response::

    {
        "action": "get_bar",
        "errors": [],
        "body": {
            "bar": {
                "_type": "bar",
                "id": 2,
                "stuff": "things",
            },
        },
    }

The ``bar_example`` response is added to the original response from the ``foo_example`` service, replacing the ``bar_id`` field (``source_field``) with the ``bar`` field  (``dest_field``). The final response body looks like::

    {
        "foo": {
            "_type": "foo",
            "id": 1,
            "bar": {
                "_type": "bar",
                "id": 2,
                "stuff": "things",
            },
        },
    }
    

Client exceptions
+++++++++++++++++

- ``ImproperlyConfigured``: The ``Client`` tried to call a service for which it did not have configuration.

- ``JobError``: Raised by ``Client.call_action`` and ``Client.call_actions`` when the ``JobResponse`` contains job-level errors.

- ``CallActionError``: Raised by ``Client.call_action`` and ``Client.call_actions`` when the ``JobResponse`` contains action-level errors.



Serialization
-------------

The ``Serializer`` class allows Clients and Servers to communicate using a common format. This library provides serializer classes for the JSON and msgpack formats, and the base ``Serializer`` class can be extended to use any format that a developer may wish to use. The ``Serializer`` interface is simple:

``Serializer``
++++++++++++++

Properties:

- ``mime_type``: A unique string that identifies the type of serializer used to encode a message. Generally of the form ``application/format`` where ``format`` is the lower-case alphanumeric name of the message format.

Methods:

- ``dict_to_blob``: Takes a Python dictionary and serializes it to a binary string.

- ``blob_to_dict``: Takes a binary string and deserializes it to a Python dictionary.


Provided serializers
++++++++++++++++++++


MessagePack Serializer
**********************

- Backend: `msgpack-python <https://pypi.python.org/pypi/msgpack-python>`_
- Types supported: ``int``, ``str``, ``dict``, ``list``, ``tuple``, ``bytes`` (Python 3 only)
- Other notes: Makes no distinction between ``list`` and ``tuple`` types. Both types will be deserialized as lists.


JSON Serializer
***************

- Backend: `json <https://docs.python.org/2/library/json.html>`_
- Types supported: ``int``, ``str``, ``dict``, ``list``, ``tuple``
- Other notes: Makes no distinction between ``list`` and ``tuple`` types. Both types will be deserialized as lists.


Serializer configuration
++++++++++++++++++++++++

The config schema for ``Serializer`` objects is just the basic ``pysoa`` plugin schema::

    {
        "path": <path to serializer class>,
        "kwargs": <optional dict of keyword args>,
    }


Serializer exceptions
+++++++++++++++++++++

- ``InvalidField``: Raised when the serializer fails to serialize a message. Contains the arguments from the original exception raised by the serialization backend's encoding function.

- ``InvalidMessage``: Raised when the serializer fails to deserialize a message. Contains the arguments from the original exception raised by the serialization backend's decoding function.



Transport
---------

The ``transport`` module provides an interface for sending messages between clients and servers. There are two base classes:

``ClientTransport``
+++++++++++++++++++

Methods:

- ``__init__`` - Args:

  + ``service_name``: The name of the service that the transport is for.

- ``send_request_message``: Send a serialized request to a server. Args:

  + ``request_id``: The ID of the request being sent. This is provided by the client and must be returned with the response, to allow the client to keep track of message order.
  + ``meta``: A dictionary containing any metadata required for the server to process the message and return a response. At a minimum, includes the mime type of the serializer used to encode the message so that the server can decode it and correctly encode the response.
  + ``message_string``: The raw message, as encoded by the serializer's ``dict_to_blob`` method.

- ``receive_response_message``: Returns a tuple of (``request_id``, ``response_message_string``).


``ServerTransport``
+++++++++++++++++++

Methods:

- ``__init__`` - Args:

  + ``service_name``: The name of the service that the transport is for.

- ``receive_request_message``: Return a tuple of (``request_id``, ``meta``, ``request_message_string``).

- ``send_response_message``: Send a serialized request to the client that sent the response. Args:

  + ``request_id``: The ID of the request corresponding to the response being sent. This is provided by ``receive_request_message``.
  + ``meta``: The same ``meta`` sent by ``ClientTransport.send_request_message``.
  + ``message_string``: The raw message, as encoded by the serializer's ``dict_to_blob`` method.


Transport configuration
+++++++++++++++++++++++

The config schema for ``Transport`` classes is the same as for other ``pysoa`` plugins::

    {
        "path": <path to transport class>,
        "kwargs": <optional dict of keyword args>,
    }


Transport exceptions
++++++++++++++++++++

- ``InvalidMessageError``: The transport tried to send or receive a message that was malformed.
- ``MessageTooLarge``: The message passed to the transport exceeded the maximum size allowed by the transport.
- ``ConnectionError``: The transport failed to connect to its message backend.
- ``MessageSendTimeout``: The transport timed out while trying to send a message.
- ``MessageSendError``: The transport encountered any other error while trying to send a message.
- ``MessageReceiveTimeout``: The transport timed out while waiting to receive a message.
- ``MessageReceiveError``: The transport encountered any other error while trying to receive a message.


Redis Gateway Transport
+++++++++++++++++++++++

The ``transport.redis_gateway`` module provides a transport implementation that uses Redis (in simple or Sentinel mode)
for sending and receiving messages. This is the recommended transport for use with ``pysoa``, as it provides a
convenient and performant backend for asynchronous service requests.

Standard and Sentinel modes
***************************

The Redis Gateway transport has two primary modes of operation: in "standard" mode, the channel layer will connect to a
specified list of Redis hosts, while in "Sentinel" mode, the channel layer will connect to a list of Sentinel hosts and
use Sentinel to find its Redis hosts.

Configuration
*************

The Redis Gateway transport takes the following extra keyword arguments for configuration:

- ``backend_type``: Either "redis.standard" or "redis.sentinel" to specify which Redis backend to use (required)

- ``backend_layer_kwargs``: A dictionary of arguments to pass to the backend layer

  + ``connection_kwargs``: A dictionary of arguments to pass to the underlying Redis client

  + ``hosts``: A list of strings (host names / IP addresses) or tuples (host names / IP addresses and ports) for Redis hosts or sentinels to which to connect (will use "localhost" by default)

  + ``redis_db``: The Redis database number to use (a shortcut for specifying ``connection_kwargs['db']``)

  + ``redis_port``: The connection port to use (a shortcut for providing this for every entry in ``hosts``

  + ``sentinel_refresh_interval``: How often, in seconds, master/slave data should be refreshed from the Sentinel (only for type "redis.sentinel") (refreshes every connection by default)

  + ``sentinel_services``: Which Sentinel services to use (only for type "redis.sentinel") (will be auto-discovered from the Sentinel by default)

- ``message_expiry_in_seconds``: How long a message may remain in the queue before it is considered expired and discarded

- ``queue_capacity``: The maximum number of messages a given Redis queue may hold before the transport should stop pushing messages to it (defaults to 10,000)

- ``queue_full_retries``: The number of times the transport should retry sending to a Redis queue that is at capacity before it raises an error and stops trying (defaults to 10)

- ``receive_timeout_in_seconds``: How long the transport should block waiting to receive a message before giving up (on the server, this controls how often the server request-process loops; on the client, this controls how long before it raises an error for waiting too long for a response)

- ``serializer_config``: A standard serializer configuration as described in `Serializer configuration`_ (defaults to Msgpack)


ASGI Transport (DEPRECATED)
+++++++++++++++++++++++++++

**WARNING:** The ASGI transport is deprecated due to performance issues. It will be removed before the first 1.0.0 GA
release. Please migrate your projects to the `Redis Gateway Transport`_.

The ``transport.asgi`` module provides a transport implementation that uses the `ASGI <http://channels.readthedocs.io/en/stable/asgi.html>`_ protocol. It is also the technology underlying `Django channels <https://channels.readthedocs.io/en/stable/>`_.

The reference ASGI implementation, used in ``transport.asgi``, uses Redis as a message backend. The protocol is backend-agnostic, however; if you need to use a different backend, you can implement your own ``ASGITransportCore`` or extend the existing one.


Redis and Sentinel modes
************************
The ASGI transport has two primary modes of operation: in Redis mode, the channel layer will connect to a specified list of Redis hosts, while in Sentinel mode, the channel layer will connect to a list of Sentinel hosts and use Sentinel to find its Redis hosts.


Configuration
*************

The ASGI transports take the following extra keyword arguments for configuration:

- ``asgi_channel_type``: Specifies the type of channel to be used by the ASGI backend. There are three options: ``ASGI_CHANNEL_TYPE_LOCAL``, ``ASGI_CHANNEL_TYPE_REDIS_SENTINEL`` and ``ASGI_CHANNEL_TYPE_REDIS``. The Redis backend types are intended for production use, while the local type is intended primarily for testing.

- ``redis_hosts`` (optional): If ``ASGI_CHANNEL_TYPE_REDIS`` is set, specifies the Redis hosts that the channel layer will connect to. If ``ASGI_CHANNEL_TYPE_REDIS_SENTINEL`` is set, specifies the Sentinel hosts that the channel layer will connect to. Hosts can be specified as either ``(host, port)`` pairs, or host address only. If the address alone is used, all connections will be made to the port specified by ``redis_port``. Defaults to ``('localhost', 6379)``. Not required for local channels.

- ``redis_port`` (optional): The port that the transport will use to connect to Redis. Not required for local channels, or if specifying hosts using ``(host, port)`` pairs. Defaults to 6379.

- ``sentinel_refresh_interval`` (optional): Number of seconds for which the Sentinel channel layer will cache its master connections. Only used in Sentinel mode. Defaults to 30 seconds.

- ``sentinel_services`` (optional): Services to connect to in Sentinel. Only used in Sentinel mode. Defaults to the empty list, in which case the channel layer will automatically discover all available services.

- ``redis_db`` (optional): The Redis database, specified by an integer, that the transport will connect to. Not required for local channels. Defaults to 0.

- ``channel_layer_kwargs`` (optional): A dict of extra keyword arguments to be passed to the channel layer. This is typically not necessary, but it gives you the option to fine-tune your Redis connection. Descriptions of the channel layer arguments can be found on the `asgi_redis page <https://github.com/django/asgi_redis>`_. The following keys will have their values overridden, so don't try to set them:

  + ``hosts``: Overridden with the sanitized values of ``redis_hosts``.

  + ``connection_kwargs.db``: ``redis_db``

  + ``sentinel_refresh_interval``: ``sentinel_refresh_interval`` (Sentinel mode only)

  + ``services``: ``sentinel_services`` (Sentinel mode only)

- ``channel_full_retries`` (optional): Number of times the transport will retry sending a message when the channel is full. Defaults to 10.



Middleware
----------

Middleware for both ``Server`` and ``Client`` uses an onion calling pattern, where each middleware accepts a callable and returns a callable. Each middleware in the stack is called with the middleware below it, and the base level middleware is called with a base processing method from the ``Server`` or ``Client``.


``ServerMiddleware``
++++++++++++++++++++

The ``ServerMiddleware`` class has an interface that allows it to act at a Job level or at an Action level, or both, depending on which part(s) of the interface it implements:

Methods:

- ``job``: Takes a single argument, ``process_job``, that is a callable that takes a ``JobRequest`` and returns a ``JobResponse``. The ``request`` method should return a callable with the same signature as ``process_job``.

- ``action``: Takes a single argument, ``process_action``, that is a callable that takes an ``ActionRequest`` and returns an ActionResponse. The ``response`` method should return a callable with the same signature as ``process_action``.


``ClientMiddleware``
++++++++++++++++++++

Client middleware works similarly to server middleware, using an onion calling pattern. Client middleware is built around the client request/response workflow. The ``ClientMiddleware`` class has two methods, ``request`` and ``response``, each of which wraps a callable that does the work of sending or receiving, respectively.

- ``request``: Takes a callable with the signature ``(request_id, meta, request)``, where ``request`` is a ``JobRequest``, ``meta`` is a dictionary and ``request_id`` is an integer. Sends the ``JobRequest`` and returns ``None``. The ``request`` method should return a callable with the same signature as ``send_request``. It should process the ``JobRequest``, call ``send_request(request_id, meta, request)`` and return ``None``.

- ``response``: Takes a callable that takes no arguments and returns a tuple of ``(request_id, response)`` where ``response`` is a  ``JobResponse`` and ``request_id`` is an integer. The ``response`` method should return a callable with the same signature as ``get_response``. It should call ``get_response()``, process the ``JobResponse`` and return ``(request_id, response)``.


Middleware configuration
++++++++++++++++++++++++

``Middleware`` classes are configured using the standard ``pysoa`` plugin schema::

    {
        "path": <path to middleware class>,
        "kwargs": <optional dict of keyword args>,
    }


Metrics
-------
PySOA is capable of recording detailed metrics about the performance of its client and server transports and sending
and receiving processes. If you wish to gather metrics about the performance of PySOA, you will need to enable this
metrics recording in your server settings and/or in your client settings and provide an object which PySOA can use to
record these metrics.

``MetricsRecorder``
+++++++++++++++++++

Metrics in PySOA are recorded with an implementation of the ``MetricsRecorder`` abstract class. By default, PySOA ships
with and uses a ``NoOpMetricsRecorder`` that performs no action recorder of metrics. In order to record metrics in your
application, you will need to supply an implementation that knows about your metrics backend and understands how to
record counters and timers. The documentation for ``Counter``, ``Timer``, and ``MetricsRecorder`` in
``pysoa/common/metrics.py`` details how to implement these classes.

Metrics configuration
+++++++++++++++++++++

Metrics are configured using the standard ``pysoa`` plugin schema::

    {
        "path": <path to class implementing MetricsRecorder>,
        "kwargs": <optional dict of keyword args passed to your MetricsRecorder class when instantiated>,
    }

PySOA does not automatically append any sort of distinguishing prefix to the metrics it records (see `Which metrics
are recorded`_ below). We recommend your ``MetricsRecorder`` append some type of prefix to all metrics names passed to
it so that you can group all PySOA metrics together.

Which metrics are recorded
++++++++++++++++++++++++++

These are all the metrics recorded in PySOA:

- ``server.transport.redis_gateway.send``: A timer indicating how long it takes the Redis Gateway server transport to send a response
- ``server.transport.redis_gateway.send.error.missing_reply_queue``: A counter incremented each time the Redis Gateway server transport is unable to send a response because the message metadata is missing the required ``reply_to`` attribute
- ``server.transport.redis_gateway.send.serialize``: A timer indicating how long it takes the Redis Gateway transport to serialize a message
- ``server.transport.redis_gateway.send.error.message_too_large``: A counter incremented each time the Redis Gateway transport fails to send because it exceeds 100 kilobytes
- ``server.transport.redis_gateway.send.queue_full_retry``: A counter incremented each time the Redis Gateway transport re-tries sending a message because the message queue was temporarily full
- ``server.transport.redis_gateway.send.queue_full_retry.retry_{1...n}``: A counter incremented on each queue full retry for a particular retry number
- ``server.transport.redis_gateway.send.get_redis_connection``: A timer indicating how long it takes the Redis Gateway transport to get a connection to the Redis cluster or sentinel
- ``server.transport.redis_gateway.send.send_message_to_redis_queue``: A timer indicating how long it takes the Redis Gateway transport to push a message onto the queue
- ``server.transport.redis_gateway.send.error.unknown``: A counter incremented each time the Redis Gateway transport encounters an unknown error (logged) sending a message
- ``server.transport.redis_gateway.send.error.redis_queue_full``: A counter incremented each time the Redis Gateway transport fails to push a message onto a full queue after the maximum configured retries
- ``server.transport.redis_gateway.receive``: A timer indicating how long it takes the Redis Gateway server transport to receive a response (however, this includes time waiting for an incoming request, so it may not be meaningful)
- ``server.transport.redis_gateway.receive.get_redis_connection``: A timer indicating how long it takes the Redis Gateway transport to get a connection to the Redis cluster or sentinel
- ``server.transport.redis_gateway.receive.pop_from_redis_queue``: A timer indicating how long it takes the Redis Gateway transport to pop a message from the redis queue (however, this includes time waiting for an incoming message, so it may not be meaningful)
- ``server.transport.redis_gateway.receive.error.unknown``: A counter incremented each time the Redis Gateway transport encounters an unknown error (logged) receiving a message
- ``server.transport.redis_gateway.receive.deserialize``: A timer indicating how long it takes the Redis Gateway transport to deserialize a message
- ``server.transport.redis_gateway.receive.error.message_expired``: A counter incremented each time the Redis Gateway transport receives an expired message
- ``server.transport.redis_gateway.receive.error.no_request_id``: A counter incremented each time the Redis Gateway transport receives a message with a missing required Request ID
- ``server.error.serialization_failure``: A counter incremented each time a serialization error occurs in the server
- ``server.error.job_error``: A counter incremented each time a handled error occurs processing a job
- ``server.error.unhandled_error``: A counter incremented each time an unhandled error occurs processing a job
- ``server.error.error_formatting_failure``: A counter incremented each time an error occurs handling an error
- ``server.error.variable_formatting_failure``: A counter incremented each time an error occurs handling an error
- ``server.error.unknown``: A counter incremented each time some unknown error occurs that escaped all other error detection
- ``client.transport.redis_gateway.send``: A timer indicating how long it took the Redis Gateway client transport to send a request
- ``client.transport.redis_gateway.send.serialize``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.send.error.message_too_large``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.send.queue_full_retry``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.send.queue_full_retry.retry_{1...n}``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.send.get_redis_connection``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.send.send_message_to_redis_queue``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.send.error.unknown``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.send.error.redis_queue_full``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.receive``: A timer indicating how long it took the Redis Gateway client transport to receive a response (however, this includes time blocking for a response, so it may not be meaningful)
- ``client.transport.redis_gateway.receive.get_redis_connection``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.receive.pop_from_redis_queue``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.receive.error.unknown``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.receive.deserialize``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.receive.error.message_expired``: Client metric has same meaning as server metric
- ``client.transport.redis_gateway.receive.error.no_request_id``: Client metric has same meaning as server metric
- ``client.send.excluding_middleware``: A timer indicating how long it took to send a request through the configured transport, excluding any time spent in middleware
- ``client.send.including_middleware``: A timer indicating how long it took to send a request through the configured transport, including any time spent in middleware
- ``client.receive.excluding_middleware``: A timer indicating how long it took to receive a request through the configured transport, excluding any time spent in middleware (however, this includes time blocking for a response, so it may not be meaningful)
- ``client.receive.including_middleware``: A timer indicating how long it took to receive a request through the configured transport, including any time spent in middleware (however, this includes time blocking for a response, so it may not be meaningful)


Customizing configuration
-------------------------

The ``settings`` module provides classes that contain and validate settings for Clients and Servers. It has three primary functions: schema validation, defaults and import resolution.

- Schema validation: Settings performs validation on input values using `conformity <https://github.com/eventbrite/conformity>`_. Subclasses merge their schema with that of their parents, to a depth of 1.

- Defaults: Subclasses may define defaults as a dictionary. Defaults defined on a subclass will be merged with the defaults of its parent, to a depth of 1. For example::

    class BaseSettings(Settings):
        schema = {
            "foo": conformity.fields.Integer(),
            "bar": conformity.fields.SchemalessDictionary(key_type=conformity.fields.UnicodeString()),
        }
        defaults = {
            "foo": 1,
            "bar": {"baz": 2},
        }

    class MySettings(BaseSettings):
        defaults = {
            "bar": {"quas": 3}
        }

  The class MySettings will have the defaults ``{"foo": 1, "bar": {"quas": 3}}``. This provides a measure of convenience while discouraging deep inheritance structures.

  When a ``Settings`` instance is created, the provided dictionary of values is merged recursively with the class's defaults::

    my_settings = MySettings({"bar": {"some_setting": 42}})
    my_settings["foo"]
    > 1
    my_settings["bar"]["quas"]
    > 3
    my_settings["bar"]["some_setting"]
    > 42

- Import resolution: Settings classes may define methods to resolve import paths to objects. For each key in its input value, a ``Settings`` object will check to see if it has a method called ``convert_<key>``, and will call it with the corresponding value. For example::

    class FooSettings(Settings):
        schema = {
            "serializer": conformity.fields.Dictionary({
                "path": conformity.fields.UnicodeString(),
            }),
        }

        def convert_serializer(self, value):
            if "object" not in value:
                try:
                    value["object"] = self.resolve_python_path(value["path"])
                except ImportError:
                    raise self.ImproperlyConfigured(
                        "Could not resolve path {} for configuration:\n{}".format(value["path"], value))
            return value

    my_settings = FooSettings({
        "serializer": {
            "path": "pysoa.common.serializer:JSONSerializer"
        }
    })

    my_settings["serializer"]["object"]
    > pysoa.common.serializer.json_serializer.JSONSerializer

  The method ``resolve_python_path`` takes care of the import for you. The ``Settings`` class also provides a convenience method called ``standard_convert_path`` that converts a value exactly as above, so ``convert_serializer`` could simply be written as::

    def convert_serializer(self, value):
        return self.standard_convert_path(value)


Included ``Settings`` subclasses
++++++++++++++++++++++++++++++++

``common.settings.SOASettings`` provides a schema that is shared by both Servers and Clients.

- Schema:

  + ``transport``: Import path and keyword args for a ``Transport`` class.

  + ``serializer``: Import path and keyword args for a ``Serializer`` class.

  + ``middleware``: List of dicts containing import path and keyword args for a ``ClientMiddleware`` or ``ServerMiddleware`` class.

Both the ``client`` and ``server`` modules implement their own subclasses that inherit from ``SOASettings``. Developers implementing ``Client`` or ``Server`` subclasses may wish to subclass the respective settings class in order to alter or extend the settings.

