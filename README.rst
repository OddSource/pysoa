pysoa
=====

A general-purpose library for writing Python services and their clients. Consists of ``server``, ``client`` and ``common`` submodules.

.. contents:: Contents
   :depth: 3
   :backlinks: none


The service API
---------------

Services in ``pysoa`` are built around a simple service API. The core abstractions of this API are jobs and actions. An action is a unit of work performed by a Server, while a job is a container of actions.

Jobs and actions are represented in code as objects with the following structures:

JobRequest
++++++++++

``control`` - A dict with the following keys, as well as any other keys required by the implementation:

+ ``switches``: A list of switch values (see below).
+ ``continue_on_error``: Tells the Server whether to continue processing the job if any action results in an error (``bool``).
+ ``correlation_id``: A unique ID that is generated by the Client and follows the job. Must be passed to any other service calls made while processing the job. Used to facilitate metrics (``str``).

``context``: A dict containing arbitrary values that do not affect the execution of the job. Generally used for metadata.
``actions``: A list containing ``ActionRequests``.

ActionRequest
+++++++++++++

``action``: The name of the action (``str``).

``body``: A dict contianing arguments for the action.

JobResponse
+++++++++++

``actions``: A list of ``ActionResponses``

``errors``: A list of ``Errors``

ActionResponse
++++++++++++++

``action``: The name of the action (``str``).

``errors``: A list of ``Errors``.

``body``: A dict containing the return value of the action.

Error
+++++

``code``: A numerical error code (``int``).

``message``: A human-readable error message (``str``).

``field``: An identifier of the form ``'field.subfield'`` for the field in the ``ActionRequest`` that caused the error, if applicable (``str``).


The Server module
-----------------

Versioning using switches
+++++++++++++++++++++++++

Switches are like a special argument that every action in a job gets. In terms of code, switches are simply integers passed by the Client in the control header of every ``JobRequest``, and then by the Server into every action in that job.

Switches came from a need to version individual service actions, rather than versioning the whole service at once. To do this, implement a switching function that calls a different action depending on the switches in the ``ActionRequest``. For example::


    MY_ACTION_V2 = 1

    class MyAction(Action):
        ...

    class MyActionV2(Action):
        ...

    def my_action(action_request):
        if MY_ACTION_V2 in action_request.switches:
            return MyActionV2(action_request)
        else:
            return MyAction(action_request)


The Client module
-----------------

The ``client`` submodule provides the ``Client`` class as well as routing and plugin classes.

Client
++++++

The ``Client`` class can be used to communicate with services that are written using the ``Server`` class or that implement the same API. The ``Client`` provides a convenient interface for calling service actions, receiving responses and handling exceptions.

``Client``:

- ``service_name``: Name of the service to be called (``str``).
- ``transport``: A ``Transport`` instance.
- ``serializer``: A ``Serializer`` instance.
- ``middleware`` (optional): A list of ``ClientMiddleware`` isntances (optional).


``Client.call_actions`` - Build and send a ``JobRequest`` from ``ActionRequest`` objects and control args and return an ``ActionResponse``. Args:

- ``actions``: A list of ``ActionRequests``
- ``context`` (optional): Corresponds to the ``context`` dict in ``JobRequest``.
- ``correlation_id``, ``continue_on_error`` (optional): Values that will be included in ``JobRequest.control``.
- ``control_extra`` (optional): A dict containing any extra values that will be included in ``JobRequest.control``.

``Client.call_action`` - Build and send a ``JobRequest`` from action arguments and control args and return an ``ActionResponse``. Args:

- ``action_name``: The action name (``str``).
- ``body`` (optional): A dict containing arguments for the action.
- ``correlation_id``, ``continue_on_error``, ``control_extra`` (optional): Same as in ``call_actions``.

``Client.send_request`` - Asynchronously sends a request and returns an integer request ID. Args:

- ``request``: ``JobRequest``

``Client.get_all_responses`` - Gets all outstanding requests and yields them as a generator.


Client settings format
++++++++++++++++++++++

Settings for the default ``ClientSettings`` class have the following structure::


    my_service_settings = {
        'service_name': {
            'client': {
                'path': 'path.to.my.client:MyClient',
                'kwargs': {}, # optional
            },
            'transport': {
                'path': 'path.to.my.transport:MyTransport',
                'kwargs': {'foo': 'bar'}, # optional
            },
            'serializer': {
                'path': 'path.to.my.serializer:Myserializer',
                'kwargs': {'baz': 'quas'}, # optional
            },
            'middleware': [
                ('path.to.my.middleware:MyMiddleware', {'wex': 'exort'}),
                ...
            ],
            'cacheable': False,
        },
        ...
    }

The ``client``, ``transport`` and ``serializer`` sections contain the import path and keyword arguments for ``Client``, ``Transport`` and ``Serializer`` classes, respectively. The ``middleware`` section contains a list of tuples of (import path, keyword arguments) for ``ClientMiddleware`` classes.

The ``cacheable`` parameter indicates whether the ``Client`` instance for this service should be cached by the router (see `Caching`_).

A settings dict containing multiple services must have settings for each service. In order to simplify the process, developers may wish to subclass ``ClientSettings`` to provide defaults for their services (see `Settings`_).

Router
++++++

The ``ClientRouter`` class provides a standard interface for instantiating clients for services. It takes a settings dict and provides the following interface:

``ClientRouter``:

- ``config``: A settings dict, as described in `Client settings format`_.
- ``settings_class``: A subclass of ``Settings`` that the router will use to parse the settings dict that is passed to it, as described in `Settings`_.

``ClientRouter.get_client``: Instantiate and return a ``Client`` for the provided service name. Automatically instatntiates and provides transport, serializer and middleware classes to the ``Client``, based on the provided settings for the service.

- ``service_name``: Name of the service (``str``).
- ``kwargs``: Any keyword arguments provided will be passed to the ``Client`` as initialization arguments.

Caching
*******

If the service settings specify that the client is ``cacheable``, subsequent calls to ``get_client`` after the first will return the same ``Client`` instance. Be careful with caching clients that take keyword arguments, as the router will return the ``Client`` instance from the *first* call, regardless of the keyword arguments to subsequent calls.


The Common module
-----------------

Serializer
++++++++++

Transport
+++++++++

Settings
++++++++


